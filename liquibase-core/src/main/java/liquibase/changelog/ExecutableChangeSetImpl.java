package liquibase.changelog;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import liquibase.ContextExpression;
import liquibase.Labels;
import liquibase.change.Change;
import liquibase.change.CheckSum;
import liquibase.change.DbmsTargetedChange;
import liquibase.change.ExecutableChange;
import liquibase.change.ExecutableChangeFactory;
import liquibase.changelog.visitor.ChangeExecListener;
import liquibase.database.Database;
import liquibase.database.DatabaseList;
import liquibase.database.ObjectQuotingStrategy;
import liquibase.exception.DatabaseException;
import liquibase.exception.MigrationFailedException;
import liquibase.exception.PreconditionErrorException;
import liquibase.exception.PreconditionFailedException;
import liquibase.exception.RollbackFailedException;
import liquibase.exception.SetupException;
import liquibase.exception.UnexpectedLiquibaseException;
import liquibase.executor.Executor;
import liquibase.executor.ExecutorService;
import liquibase.logging.LogFactory;
import liquibase.logging.Logger;
import liquibase.parser.core.ParsedNode;
import liquibase.parser.core.ParsedNodeException;
import liquibase.precondition.Conditional;
import liquibase.precondition.ErrorPrecondition;
import liquibase.precondition.FailedPrecondition;
import liquibase.precondition.core.PreconditionContainer;
import liquibase.precondition.core.PreconditionService;
import liquibase.resource.ResourceAccessor;
import liquibase.serializer.LiquibaseSerializable;
import liquibase.sql.visitor.SqlVisitor;
import liquibase.statement.SqlStatement;
import liquibase.util.StreamUtil;
import liquibase.util.StringUtils;

/**
 * Encapsulates a changeSet and all its associated changes.
 */
public class ExecutableChangeSetImpl implements Conditional, LiquibaseSerializable, ExecutableChangeSet {

    private ChangeLogParameters changeLogParameters;

    private Logger log;

    /**
     * Behavior if the validation of any of the changeSet changes fails.  Does not include checksum validation
     */
    private ValidationFailOption onValidationFail = ValidationFailOption.HALT;

    /**
     * Stores if validation failed on this chhangeSet
     */
    private boolean validationFailed;

    /**
     * SqlVisitors defined for this changeset.
     * SqlVisitors will modify the SQL generated by the changes before sending it to the database.
     */
    private List<SqlVisitor> sqlVisitors = new ArrayList<SqlVisitor>();

    private ChangeSetImpl delegate;

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#shouldAlwaysRun()
     */
    @Override
    public boolean shouldAlwaysRun() {
        return delegate.shouldAlwaysRun();
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#shouldRunOnChange()
     */
    @Override
    public boolean shouldRunOnChange() {
        return delegate.shouldRunOnChange();
    }

    public ExecutableChangeSetImpl(DatabaseChangeLog databaseChangeLog) {
        this.delegate = new ChangeSetImpl(databaseChangeLog);
        log = LogFactory.getLogger();
    }

    public ExecutableChangeSetImpl(ChangeSetImpl delegate) {
        this.delegate = delegate;
        log = LogFactory.getLogger();
    }

    public ExecutableChangeSetImpl(String id, String author, boolean alwaysRun, boolean runOnChange, String filePath, String contextList, String dbmsList, DatabaseChangeLog databaseChangeLog) {
        this(id, author, alwaysRun, runOnChange, filePath, contextList, dbmsList, true, ObjectQuotingStrategy.LEGACY, databaseChangeLog);
    }

    public ExecutableChangeSetImpl(String id, String author, boolean alwaysRun, boolean runOnChange, String filePath, String contextList, String dbmsList, boolean runInTransaction, DatabaseChangeLog databaseChangeLog) {
        this(id, author, alwaysRun, runOnChange, filePath, contextList, dbmsList, runInTransaction, ObjectQuotingStrategy.LEGACY, databaseChangeLog);
    }

    public ExecutableChangeSetImpl(String id, String author, boolean alwaysRun, boolean runOnChange, String filePath, String contextList, String dbmsList, ObjectQuotingStrategy quotingStrategy, DatabaseChangeLog databaseChangeLog) {
        this(id, author, alwaysRun, runOnChange, filePath, contextList, dbmsList, true, quotingStrategy, databaseChangeLog);
    }

    public ExecutableChangeSetImpl(String id, String author, boolean alwaysRun, boolean runOnChange, String filePath, String contextList, String dbmsList,
                     boolean runInTransaction, ObjectQuotingStrategy quotingStrategy, DatabaseChangeLog databaseChangeLog) {
        delegate = new ChangeSetImpl(id, author, alwaysRun, runOnChange, filePath, contextList, dbmsList, runInTransaction, quotingStrategy, databaseChangeLog);
        log = LogFactory.getLogger();
    }

    protected void setDbms(String dbmsList) {
        delegate.setDbms(dbmsList);
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#getFilePath()
     */
    @Override
    public String getFilePath() {
        return delegate.getFilePath();
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#generateCheckSum()
     */
    @Override
    public CheckSum generateCheckSum() {
        StringBuffer stringToMD5 = new StringBuffer();
        for (Change change : getChanges()) {
            stringToMD5.append(change.generateCheckSum()).append(":");
        }

        for (SqlVisitor visitor : this.getSqlVisitors()) {
            stringToMD5.append(visitor.generateCheckSum()).append(";");
        }


        return CheckSum.compute(stringToMD5.toString());
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#load(liquibase.parser.core.ParsedNode, liquibase.resource.ResourceAccessor)
     */
    @Override
    public void load(ParsedNode node, ResourceAccessor resourceAccessor) throws ParsedNodeException {
        delegate.load(node, resourceAccessor);
    }

    protected ExecutableChange toChange(ParsedNode value, ResourceAccessor resourceAccessor) throws ParsedNodeException {
        ExecutableChange change = ExecutableChangeFactory.getInstance().create(value.getName());
        if (change == null) {
            return null;
        } else {
            try {
                change.load(value, resourceAccessor);
            } catch (ParsedNodeException e) {
                e.printStackTrace();
            }
            return change;
        }
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#serialize()
     */
    @Override
    public ParsedNode serialize() {
        return delegate.serialize();
    }


    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#execute(liquibase.changelog.DatabaseChangeLog, liquibase.database.Database)
     */
    @Override
    public ExecType execute(DatabaseChangeLog databaseChangeLog, Database database) throws MigrationFailedException {
        return execute(databaseChangeLog, null, database);
    }
    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#execute(liquibase.changelog.DatabaseChangeLog, liquibase.changelog.visitor.ChangeExecListener, liquibase.database.Database)
     */
    @Override
    public ExecType execute(DatabaseChangeLog databaseChangeLog, ChangeExecListener listener, Database database) throws MigrationFailedException {
        if (validationFailed) {
            return ExecType.MARK_RAN;
        }

        long startTime = new Date().getTime();

        ExecType execType = null;

        boolean skipChange = false;

        Executor executor = ExecutorService.getInstance().getExecutor(database);
        try {
            // set object quoting strategy
            database.setObjectQuotingStrategy(getObjectQuotingStrategy());

            // set auto-commit based on runInTransaction if database supports DDL in transactions
            if (database.supportsDDLInTransaction()) {
                database.setAutoCommit(!isRunInTransaction());
            }

            executor.comment("Changeset " + toString(false));
            if (StringUtils.trimToNull(getComments()) != null) {
                String comments = getComments();
                String[] lines = comments.split("\\n");
                for (int i = 0; i < lines.length; i++) {
                    if (i > 0) {
                        lines[i] = database.getLineComment() + " " + lines[i];
                    }
                }
                executor.comment(StringUtils.join(Arrays.asList(lines), "\n"));
            }
            PreconditionContainer preconditions = getPreconditions();
            try {
                if (preconditions != null) {
                    PreconditionService service = new PreconditionService(preconditions);
                    service.check(preconditions, database, databaseChangeLog, this);
                }
            } catch (PreconditionFailedException e) {
                if (listener != null) {
                    listener.preconditionFailed(e, preconditions.getOnFail());
                }
                StringBuffer message = new StringBuffer();
                message.append(StreamUtil.getLineSeparator());
                for (FailedPrecondition invalid : e.getFailedPreconditions()) {
                    message.append("          ").append(invalid.toString());
                    message.append(StreamUtil.getLineSeparator());
                }

                if (preconditions.getOnFail().equals(PreconditionContainer.FailOption.HALT)) {
                    throw new MigrationFailedException(this, message.toString(), e);
                } else if (preconditions.getOnFail().equals(PreconditionContainer.FailOption.CONTINUE)) {
                    skipChange = true;
                    execType = ExecType.SKIPPED;

                    LogFactory.getLogger().info("Continuing past: " + toString() + " despite precondition failure due to onFail='CONTINUE': " + message);
                } else if (preconditions.getOnFail().equals(PreconditionContainer.FailOption.MARK_RAN)) {
                    execType = ExecType.MARK_RAN;
                    skipChange = true;

                    log.info("Marking ChangeSet: " + toString() + " ran despite precondition failure due to onFail='MARK_RAN': " + message);
                } else if (preconditions.getOnFail().equals(PreconditionContainer.FailOption.WARN)) {
                    execType = null; //already warned
                } else {
                    throw new UnexpectedLiquibaseException("Unexpected precondition onFail attribute: " + preconditions.getOnFail(), e);
                }
            } catch (PreconditionErrorException e) {
                if (listener != null) {
                    listener.preconditionErrored(e, preconditions.getOnError());
                }

                StringBuffer message = new StringBuffer();
                message.append(StreamUtil.getLineSeparator());
                for (ErrorPrecondition invalid : e.getErrorPreconditions()) {
                    message.append("          ").append(invalid.toString());
                    message.append(StreamUtil.getLineSeparator());
                }

                if (preconditions.getOnError().equals(PreconditionContainer.ErrorOption.HALT)) {
                    throw new MigrationFailedException(this, message.toString(), e);
                } else if (preconditions.getOnError().equals(PreconditionContainer.ErrorOption.CONTINUE)) {
                    skipChange = true;
                    execType = ExecType.SKIPPED;

                } else if (preconditions.getOnError().equals(PreconditionContainer.ErrorOption.MARK_RAN)) {
                    execType = ExecType.MARK_RAN;
                    skipChange = true;

                    log.info("Marking ChangeSet: " + toString() + " ran despite precondition error: " + message);
                } else if (preconditions.getOnError().equals(PreconditionContainer.ErrorOption.WARN)) {
                    execType = null; //already logged
                } else {
                    throw new UnexpectedLiquibaseException("Unexpected precondition onError attribute: " + preconditions.getOnError(), e);
                }

                database.rollback();
            } finally {
                database.rollback();
            }

            if (!skipChange) {
                for (Change change : delegate.getChanges()) {
                    try {
                        change.finishInitialization();
                    } catch (SetupException se) {
                        throw new MigrationFailedException(this, se);
                    }
                }

                log.debug("Reading ChangeSet: " + toString());
                for (Change c : getChanges()) {
                    ExecutableChange change = (ExecutableChange) c;
                    if ((!(change instanceof DbmsTargetedChange)) || DatabaseList.definitionMatches(((DbmsTargetedChange) change).getDbms(), database, true)) {
                        if (listener != null) {
                            listener.willRun(change, this, getChangeLog(), database);
                        }
                        database.executeStatements(change, databaseChangeLog, sqlVisitors);
                        log.info(change.getConfirmationMessage());
                        if (listener != null) {
                            listener.ran(change, this, getChangeLog(), database);
                        }
                    } else {
                        log.debug("Change " + change.getSerializedObjectName() + " not included for database " + database.getShortName());
                    }
                }

                if (delegate.isRunInTransaction()) {
                    database.commit();
                }
                log.info("ChangeSet " + toString(false) + " ran successfully in " + (new Date().getTime() - startTime + "ms"));
                if (execType == null) {
                    execType = ExecType.EXECUTED;
                }
            } else {
                log.debug("Skipping ChangeSet: " + toString());
            }

        } catch (Exception e) {
            try {
                database.rollback();
            } catch (Exception e1) {
                throw new MigrationFailedException(this, e);
            }
            if (getFailOnError() != null && !getFailOnError()) {
                log.info("Change set " + toString(false) + " failed, but failOnError was false.  Error: " + e.getMessage());
                log.debug("Failure Stacktrace", e);
                execType = ExecType.FAILED;
            } else {
                log.severe("Change Set " + toString(false) + " failed.  Error: " + e.getMessage(), e);
                if (e instanceof MigrationFailedException) {
                    throw ((MigrationFailedException) e);
                } else {
                    throw new MigrationFailedException(this, e);
                }
            }
        } finally {
            // restore auto-commit to false if this ChangeSet was not run in a transaction,
            // but only if the database supports DDL in transactions
            if (!delegate.isRunInTransaction() && database.supportsDDLInTransaction()) {
                try {
                    database.setAutoCommit(false);
                } catch (DatabaseException e) {
                    throw new MigrationFailedException(this, "Could not resetInternalState autocommit", e);
                }
            }
        }
        return execType;
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#rollback(liquibase.database.Database)
     */
    @Override
    public void rollback(Database database) throws RollbackFailedException {
        try {
            Executor executor = ExecutorService.getInstance().getExecutor(database);
            executor.comment("Rolling Back ChangeSet: " + toString());

            // set auto-commit based on runInTransaction if database supports DDL in transactions
            if (database.supportsDDLInTransaction()) {
                database.setAutoCommit(!delegate.isRunInTransaction());
            }

            RanChangeSet ranChangeSet = database.getRanChangeSet(this);
            if (hasCustomRollbackChanges()) {

                final List<SqlStatement> statements = new LinkedList<SqlStatement>();
                for (Change change : getRollBackChanges()) {
                    ExecutableChange rollback = (ExecutableChange) change;
                    if (((rollback instanceof DbmsTargetedChange)) && !DatabaseList.definitionMatches(((DbmsTargetedChange) rollback).getDbms(), database, true)) {
                        continue;
                    }
                    SqlStatement[] changeStatements = rollback.generateStatements(database);
                    if (changeStatements != null) {
                        statements.addAll(Arrays.asList(changeStatements));
                    }
                }
                if (!statements.isEmpty()) {
                    database.executeRollbackStatements(statements.toArray(new SqlStatement[]{}), sqlVisitors);
                }

            } else {
                List<Change> changes = getChanges();
                for (int i = changes.size() - 1; i >= 0; i--) {
                    ExecutableChange change = (ExecutableChange) changes.get(i);
                    database.executeRollbackStatements(change, sqlVisitors);
                }
            }

            if (isRunInTransaction()) {
                database.commit();
            }
            log.debug("ChangeSet " + toString() + " has been successfully rolled back.");
        } catch (Exception e) {
            try {
                database.rollback();
            } catch (DatabaseException e1) {
                //ok
            }
            throw new RollbackFailedException(e);
        } finally {
            // restore auto-commit to false if this ChangeSet was not run in a transaction,
            // but only if the database supports DDL in transactions
            if (!isRunInTransaction() && database.supportsDDLInTransaction()) {
                try {
                    database.setAutoCommit(false);
                } catch (DatabaseException e) {
                    throw new RollbackFailedException("Could not resetInternalState autocommit", e);
                }
            }
        }

    }

    /**
     * Returns whether custom rollback steps are specified for this changeSet, or whether auto-generated ones should be used
     */
    protected boolean hasCustomRollbackChanges() {
        return delegate.hasCustomRollbackChanges();
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#getChanges()
     */
    @Override
    public List<Change> getChanges() {
        return delegate.getChanges();
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#addChange(liquibase.change.Change)
     */
    @Override
    public void addChange(Change change) {
        delegate.addChange(change);
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#getId()
     */
    @Override
    public String getId() {
        return delegate.getId();
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#getAuthor()
     */
    @Override
    public String getAuthor() {
        return delegate.getAuthor();
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#getContexts()
     */
    @Override
    public ContextExpression getContexts() {
        return delegate.getContexts();
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#getLabels()
     */
    @Override
    public Labels getLabels() {
        return delegate.getLabels();
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#setLabels(liquibase.Labels)
     */
    @Override
    public void setLabels(Labels labels) {
        delegate.setLabels(labels);
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#getDbmsSet()
     */
    @Override
    public Set<String> getDbmsSet() {
        return delegate.getDbmsSet();
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#getChangeLog()
     */
    @Override
    public DatabaseChangeLog getChangeLog() {
        return delegate.getChangeLog();
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#toString(boolean)
     */
    @Override
    public String toString(boolean includeMD5Sum) {
        return getFilePath() + "::" + getId() + "::" + getAuthor() + (includeMD5Sum ? ("::(Checksum: " + generateCheckSum() + ")") : "");
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#toString()
     */
    @Override
    public String toString() {
        return toString(false);
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#getComments()
     */
    @Override
    public String getComments() {
        return delegate.getComments();
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#setComments(java.lang.String)
     */
    @Override
    public void setComments(String comments) {
        delegate.setComments(comments);
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#isAlwaysRun()
     */
    @Override
    public boolean isAlwaysRun() {
        return delegate.isAlwaysRun();
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#isRunOnChange()
     */
    @Override
    public boolean isRunOnChange() {
        return delegate.isRunOnChange();
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#isRunInTransaction()
     */
    @Override
    public boolean isRunInTransaction() {
        return delegate.isRunInTransaction();
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#getRollBackChanges()
     */
    @Override
    public Change[] getRollBackChanges() {
        return delegate.getRollBackChanges();
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#addRollBackSQL(java.lang.String)
     */
    @Override
    public void addRollBackSQL(String sql) {
        delegate.addRollBackSQL(sql);
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#addRollbackChange(liquibase.change.Change)
     */
    @Override
    public void addRollbackChange(Change change) {
        delegate.addRollbackChange(change);
    }


    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#supportsRollback(liquibase.database.Database)
     */
    @Override
    public boolean supportsRollback(Database database) {
        if (getRollBackChanges() != null && getRollBackChanges().length > 0) {
            return true;
        }

        for (Change change : getChanges()) {
            if (!((ExecutableChange)change).supportsRollback(database)) {
                return false;
            }
        }
        return true;
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#getDescription()
     */
    @Override
    public String getDescription() {
        return delegate.getDescription();
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#getFailOnError()
     */
    @Override
    public Boolean getFailOnError() {
        return delegate.getFailOnError();
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#setFailOnError(java.lang.Boolean)
     */
    @Override
    public void setFailOnError(Boolean failOnError) {
        delegate.setFailOnError(failOnError);
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#getOnValidationFail()
     */
    @Override
    public ValidationFailOption getOnValidationFail() {
        return onValidationFail;
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#setOnValidationFail(liquibase.changelog.ChangeSet.ValidationFailOption)
     */
    @Override
    public void setOnValidationFail(ValidationFailOption onValidationFail) {
        this.onValidationFail = onValidationFail;
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#setValidationFailed(boolean)
     */
    @Override
    public void setValidationFailed(boolean validationFailed) {
        this.validationFailed = validationFailed;
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#addValidCheckSum(java.lang.String)
     */
    @Override
    public void addValidCheckSum(String text) {
        delegate.addValidCheckSum(text);
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#getValidCheckSums()
     */
    @Override
    public Set<CheckSum> getValidCheckSums() {
        return delegate.getValidCheckSums();
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#isCheckSumValid(liquibase.change.CheckSum)
     */
    @Override
    public boolean isCheckSumValid(CheckSum storedCheckSum) {
        // no need to generate the checksum if any has been set as the valid checksum
        for (CheckSum validCheckSum : getValidCheckSums()) {
            if (validCheckSum.toString().equalsIgnoreCase("1:any")) {
                return true;
            }
        }
        CheckSum currentMd5Sum = generateCheckSum();
        if (currentMd5Sum == null) {
            return true;
        }
        if (storedCheckSum == null) {
            return true;
        }
        if (currentMd5Sum.equals(storedCheckSum)) {
            return true;
        }

        for (CheckSum validCheckSum : getValidCheckSums()) {
            if (currentMd5Sum.equals(validCheckSum)) {
                return true;
            }
        }
        return false;
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#getPreconditions()
     */
    @Override
    public PreconditionContainer getPreconditions() {
        return delegate.getPreconditions();
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#setPreconditions(liquibase.precondition.core.PreconditionContainer)
     */
    @Override
    public void setPreconditions(PreconditionContainer preconditionContainer) {
        delegate.setPreconditions(preconditionContainer);
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#addSqlVisitor(liquibase.sql.visitor.SqlVisitor)
     */
    @Override
    public void addSqlVisitor(SqlVisitor sqlVisitor) {
        sqlVisitors.add(sqlVisitor);
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#getSqlVisitors()
     */
    @Override
    public List<SqlVisitor> getSqlVisitors() {
        return sqlVisitors;
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#getChangeLogParameters()
     */
    @Override
    public ChangeLogParameters getChangeLogParameters() {
        return changeLogParameters;
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#setChangeLogParameters(liquibase.changelog.ChangeLogParameters)
     */
    @Override
    public void setChangeLogParameters(ChangeLogParameters changeLogParameters) {
        this.changeLogParameters = changeLogParameters;
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#setFilePath(java.lang.String)
     */
    @Override
    public void setFilePath(String filePath) {
        delegate.setFilePath(filePath);
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#getObjectQuotingStrategy()
     */
    @Override
    public ObjectQuotingStrategy getObjectQuotingStrategy() {
        return delegate.getObjectQuotingStrategy();
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#getSerializedObjectName()
     */
    @Override
    public String getSerializedObjectName() {
        return "changeSet";
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#getSerializableFields()
     */
    @Override
    public Set<String> getSerializableFields() {
        return delegate.getSerializableFields();
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#getSerializableFieldValue(java.lang.String)
     */
    @Override
    public Object getSerializableFieldValue(String field) {
        return delegate.getSerializableFieldValue(field);
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#getSerializableFieldType(java.lang.String)
     */
    @Override
    public SerializationType getSerializableFieldType(String field) {
        return delegate.getSerializableFieldType(field);
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#getSerializedObjectNamespace()
     */
    @Override
    public String getSerializedObjectNamespace() {
        return delegate.getSerializedObjectNamespace();
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#getSerializableFieldNamespace(java.lang.String)
     */
    @Override
    public String getSerializableFieldNamespace(String field) {
        return getSerializedObjectNamespace();
    }


    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#equals(java.lang.Object)
     */
    @Override
    public boolean equals(Object obj) {
        if (!(obj instanceof ExecutableChangeSetImpl)) {
            return false;
        }
        return this.toString(false).equals(((ExecutableChangeSetImpl) obj).toString(false));
    }

    /* (non-Javadoc)
     * @see liquibase.changelog.IChangeSet#hashCode()
     */
    @Override
    public int hashCode() {
        return toString(false).hashCode();
    }
}
